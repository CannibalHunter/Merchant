version "4.2"

#include "ZSCRIPT.MerchantMenu.zsc"
#include "ZSCRIPT.StoreItems.zsc"

class MerchantHandler : StaticEventHandler
{
	Array<StoreItem> StoreItems;
	Array<string> Categories;

	override void OnRegister()
	{
		for (int i = 0; i < AllClasses.Size(); ++i)
		{
			if (AllClasses[i] is "StoreItem" && AllClasses[i].GetClassName() != 'StoreItem')
			{
				StoreItem Item = StoreItem(new(AllClasses[i]));
				class<Actor> a = Item.GetItem();
				if (a)
				{
					StoreItems.Push(Item);
				}
			}
		}

		for (int i = 0; i < StoreItems.Size(); ++i)
		{
			// [Ace] Don't duplicate categories.
			if (Categories.Find(StoreItems[i].GetCategory()) == Categories.Size())
			{
				Categories.Push(StoreItems[i].GetCategory());
			}
		}

		// [Ace] Sort by category index.
		for (int i = 0; i < StoreItems.Size() - 1; ++i)
		{
			for (int j = i + 1; j < StoreItems.Size(); ++j)
			{
				string C1, C2; int I1, I2;
				[C1, I1] = StoreItems[i].GetCategory();
				[C2, I2] = StoreItems[j].GetCategory();

				if (I1 > I2)
				{
					let Swap = StoreItems[i];
					StoreItems[i] = StoreItems[j];
					StoreItems[j] = Swap;
				}
			}
		}
	}

	override void NetworkProcess(ConsoleEvent e)
	{
		let plr = players[e.Player].mo;
		Array<string> ParsedName;
		e.Name.Split(ParsedName, ":");
		if (ParsedName[0] ~== "HDM_BuyStuff")
		{
			StoreItem Item;
			for (int i = 0; i < StoreItems.Size(); ++i)
			{
				if (StoreItems[i].GetClass() == ParsedName[1])
				{
					Item = StoreItems[i];
					break;
				}
			}

			if (Item && plr)
			{
				class<Inventory> ItemClass = Item.GetItem();
				int Amount = Item.GetAmount();

				int Currency = hdm_currency;
				class<Inventory> CurrencyClass = StoreItem.GetCurrencyClass(Currency);
				int Price = Item.GetAdjustedPrice(Currency);

				if (Price > plr.CountInv(CurrencyClass))
				{
					plr.A_StartSound("Merchant/BuyFailure", 15, CHANF_LOCAL | CHANF_UI);
					return;
				}

				if (ItemClass is "HDWeapon")
				{
					plr.A_SpawnItemEx(ItemClass, 6, 0, plr.height - 8, frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
				}
				else
				{
					int MaxGive = GetDefaultByType(ItemClass).MaxAmount - plr.CountInv(ItemClass);
					int MaxActualGive = min(Amount, MaxGive);

					// [Ace] Give what you can directly and drop the rest on the ground.
					plr.A_GiveInventory(ItemClass, MaxActualGive);
					Amount -= MaxActualGive;
					for (int i = 0; i < Amount; ++i)
					{
						plr.A_SpawnItemEx(ItemClass, 6, 0, plr.height - 8, frandom(-1.0, 1.0), frandom(-1.0, 1.0), frandom(2.0, 5.0), 0, SXF_NOCHECKPOSITION);
					}
				}
				plr.A_TakeInventory(CurrencyClass, Price);
				plr.A_StartSound("Merchant/BuySuccess", 16, CHANF_LOCAL | CHANF_UI);
			}
		}
	}

	override void WorldLoaded(WorldEvent e)
	{
		if (e.IsSaveGame) return;

		for (int i = 0; i < level.Sectors.Size(); ++i)
		{
			Sector CurrSec = level.Sectors[i];
			vector3 SpawnPos = (CurrSec.centerspot.x, CurrSec.centerspot.y, CurrSec.floorplane.ZAtPoint(CurrSec.centerspot));

			if (CurrSec.IsSecret() && random(1, 100) <= max(8, 20 - 2 * level.total_secrets))
			{
				Actor.Spawn("AceMerchant", SpawnPos);
				break;
			}
		}
	}

	override void WorldUnloaded(WorldEvent e)
	{
		if (hdm_currency != 1)
		{
			return;
		}

		int MoneyPerPlayer = GetMoney();
		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (players[i].mo && MoneyPerPlayer > 0)
			{
				players[i].mo.A_GiveInventory("MercenaryBucks", MoneyPerPlayer);
			}
		}
	}

	private int GetPlayersInGame()
	{
		int TotalPlayers = 0;
		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (playeringame[i])
			{
				TotalPlayers++;
			}
		}
		return TotalPlayers;
	}

	private int GetMoney() // [Ace] You know how the first bit goes.
	{
		double TotalCash = (level.killed_monsters * 0.75 + level.found_secrets * 30) - Thinker.Tics2Seconds(level.time) / 60;

		return int(TotalCash / GetPlayersInGame());
	}
}

// ----------------------------------------
// MERCHANT
// ----------------------------------------

class AceMerchant : Actor
{
	override void Tick()
	{
		if (CheckProximity("PlayerPawn", 96, 1, CPXF_ANCESTOR | CPXF_SETTARGET))
		{
			Angle = AngleTo(target);
		}
		else if (target && Distance3D(target) > 96)
		{
			// [Ace] Allow other people to talk to the NPC as well, but you'll need to keep a distance so the pointer gets nullified.
			let plr = PlayerPawn(target);
			if (plr && plr.player)
			{
				plr.player.ConversationNPC = null;
			}
		}

		Super.Tick();
	}

	override bool Used(Actor user)
	{
		if (user.PlayerNumber() == consoleplayer)
		{
			Menu.SetMenu('MerchantShopMenu');
		}

		return Super.Used(user);
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (other is "PlayerPawn")
		{
			return Super.CanCollideWith(other, passive);
		}

		return false;
	}

	Default
	{
		Mass 100;
		Height 58;
		Radius 8;
		Scale 1.0;
		+SOLID
		+PUSHABLE
		+NOBLOCKMONST
	}

	States
	{
		Spawn:
			AMRC # -1 NoDelay
			{
				frame = CVar.GetCVar("hdm_skin", players[consoleplayer]).GetInt();
			}
			Stop;
	}
}

class MercenaryBucks : HDAmmo
{
	override void SplitPickup()
	{
		int SplitAmount = min(Amount, random(20, 100));
		while (Amount > SplitAmount)
		{
			int SubSplit = min(Amount, random(20, 100));
			Actor a = Spawn("MercenaryBucks", pos);
			a.vel += vel + (frandom(-1, 1), frandom(-1, 1), frandom(-1, 1));
			Scale.X *= randompick(-1, 1);
			Inventory(a).Amount = SubSplit;
			Amount -= SubSplit;
		}

		if (amount < 1)
		{
			Destroy();
			return;
		}
	}

	override bool IsUsed()
	{
		return true;
	}

	Default
	{
		+FORCEXYBILLBOARD
		Tag "Bucks";
		Inventory.Icon "MBCKA0";
		+HDPICKUP.MULTIPICKUP
		+HDPICKUP.FITSINBACKPACK
		-HDPICKUP.DROPTRANSLATION
		HDPickup.Bulk 0.08;
		Inventory.MaxAmount 10000;
		Inventory.PickupMessage "Picked up some bucks.";
		Scale 0.4;
	}

	States
	{
		Spawn:
			MBCK A -1;
			Stop;
	}
}