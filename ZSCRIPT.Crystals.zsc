class TiberiumRadiationThinker : Thinker
{
	Sector ActiveSec;
	Array<TiberiumCrystal> Crystals;
	bool IsBlue;

	private int DamageTicker;

	override void Tick()
	{
		Super.Tick();
		for (int i = 0; i < Crystals.Size(); ++i)
		{
			if (!Crystals[i])
			{
				Crystals.Delete(i--);
			}
		}

		int crystalCount = Crystals.Size();
		if (crystalCount == 0)
		{
			Destroy();
			return;
		}

		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (!players[i].mo || players[i].mo.CurSector != ActiveSec)
			{
				continue;
			}

			bool hasRadsuit = players[i].mo.FindInventory('WornRadsuit') != null;
			int damChance = hasRadsuit ? (IsBlue ? 10 : 5) : 100;
			int damFreq = max(5, 40 - crystalCount);
			damChance += crystalCount / 3;

			if (++DamageTicker >= damFreq)
			{
				DamageTicker = 0;
				if (random(1, 100) <= damChance)
				{
					players[i].mo.DamageMobj(null, null, int((hasRadsuit ? random(2, 4) : random(8, 12)) * (IsBlue ? 1.5 : 1.0)), 'Tiberium', DMG_NO_FACTOR);

					let hdplr = HDPlayerPawn(players[i].mo);
					if (hdplr)
					{
						if (random(1, 100) <= damChance / (hasRadsuit ? 2 : 1))
						{
							hdplr.burncount += IsBlue ? randompick(1, 1, 2, 2, 2, 2, 3) : randompick(1, 1, 1, 1, 2);
						}
						if (!hasRadsuit)
						{
							hdplr.woundcount += IsBlue ? 2 : 1;
						}
					}
				}
			}
		}
	}
}

extend class MerchantHandler
{
	// [Ace] These are the opposite of healing crystals, so keep soccer moms away.
	private void SpawnCrystals(Sector s)
	{
		bool isBlue = !random(0, 16); // [Ace] Holy crystal batman, we're rich!

		double size, avgSize;
		[size, avgSize] = AceCore.GetSectorSize(s);

		double scaleFac = max(1.0, isBlue ? TiberiumCrystal.BlueScale : frandom[merchrand](-2.0, 3.0));
		int totalCrystalHealth = int(size * scaleFac);
		int originalTotal = totalCrystalHealth;

		// [Ace] I'm not using a for loop because it can potentially result in fewer than the real number of crystals to spawn.
		int tries = 0;
		TiberiumRadiationThinker tibThonk = null;

		int lowest = int.max, average = 0, highest = 0;
		while (totalCrystalHealth > 0 && tries < 5000) // [Ace] If 5000 tries dont't do it, it's likely a super tiny sector OR it's a control sector. Fringe cases probably can't be handled too well.
		{
			double angle = random(0, 359);
			double dist = frandom(0, size);
			vector3 adjPos = (s.centerspot + (dist * cos(angle), dist * sin(angle)), s.floorplane.ZAtPoint(s.centerspot));
			if (level.IsPointInLevel(adjPos) && level.PointInSector(adjPos.xy) == s)
			{
				TiberiumCrystal tib = TiberiumCrystal(Actor.Spawn('TiberiumCrystal', adjPos));
				tib.IsBlue = isBlue;
				tib.Health = int(min(totalCrystalHealth, random[merchrand](50, tib.default.health) * (isBlue ? tib.BlueScale : 1)));
				if (!tibThonk)
				{
					tibThonk = new('TiberiumRadiationThinker');
					tibThonk.ActiveSec = s;
					tibThonk.IsBlue = isBlue;
				}
				tibThonk.Crystals.Push(tib);
				totalCrystalHealth -= tib.Health;

				if (tib.Health < lowest)
				{
					lowest = tib.Health;
				}
				if (highest < tib.Health)
				{
					highest = tib.Health;
				}
				average += tib.Health;
			}
			tries++;
		}

		int crystalCount = tibThonk ? tibThonk.Crystals.Size() : 0;
		if (crystalCount > 0)
		{
			average /= crystalCount;
		}

		if (hdm_debug)
		{
			Console.Printf("--------------------\nSpawned "..(isBlue ? "\c[Blue]" : "\c[Green]").."%i\c- crystals. Remaining health: \c[Red]%i\c- out of \c[Red]%i\c- (x \c[Red]%.2f\c-). Low/avg/high: \c[Red]%i\c-/\c[Red]%i\c-/\c[Red]%i\c-.\nSector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c- size/avg is \c[Brick]%i\c-/\c[Brick]%i\c-. Took \c[Gold]%i\c- tries.",
				crystalCount, totalCrystalHealth, originalTotal, scaleFac, lowest, average, highest, s.centerspot.x, s.centerspot.y, size, avgSize, tries);
		}
	}
}

class TiberiumCrystal : Actor
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		NextDropAmount = NextDropAt = int(min(Health, frandom(35, 100 * (IsBlue ? BlueScale : 1))));
		if (IsBlue)
		{
			SetShade(0x3388FF);
		}
		bXFLIP = true;
	}

	private void DropChunk()
	{
		TiberiumChunk chonk = TiberiumChunk(Spawn('TiberiumChunk', pos));
		chonk.Amount = NextDropAmount;
		chonk.angle = random(0, 359);
		chonk.A_ChangeVelocity(frandom(1.5, 4.0), 0, frandom(2.0, 6.0), CVF_RELATIVE | CVF_REPLACE);
		chonk.IsBlue = IsBlue;

		int leftover = abs(NextDropAt);
		NextDropAmount = NextDropAt = int(min(Health, frandom(35, 100 * (IsBlue ? BlueScale : 1)))) - leftover;
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (mod == 'Chainsaw')
		{
			int dmg = Super.DamageMobj(inflictor, source, damage / 5, mod, flags, angle);

			NextDropAt -= dmg;
			if (NextDropAt <= 0)
			{
				DropChunk();
			}

			double pitch = frandom(-85.0, 85.0);
			bool success; Actor a;
			[success, a] = A_SpawnItemEx('HDSmoke', frandom(0, radius), 0,  frandom(0, height), frandom(1, 3) * cos(pitch), 0, frandom(1, 3) * sin(pitch), random(0, 359), SXF_NOCHECKPOSITION);
			a.scale = (0.6, 0.6) * frandom(0.75, 1.2);
			a.A_SetRenderStyle(1.25, STYLE_AddShaded);
			a.SetShade(IsBlue ? 0x3388FF : 0x22FF00);

			return dmg;
		}
		return 0;
	}

	const BlueScale = 3.0;
	bool IsBlue;
	private int NextDropAt;
	private int NextDropAmount;

	Default
	{
		Radius 14;
		Height 40;
		Health 300;
		Mass 50000;
		+SOLID
		+SHOOTABLE
		+DONTTHRUST
		+NOBLOOD
		Scale 0.5;
		StencilColor "66FF44";
	}

	States
	{
		RegisterSprites:
			TIBG A 0; TIBB A 0;

		Spawn:
			TIBG A 3
			{
				if (IsBlue)
				{
					sprite = GetSpriteIndex("TIBB");
				}

				double healthFac = max(0.4, Health / double(default.Health * (IsBlue ? BlueScale : 1)));
				if (random(1, 100) <= 40)
				{
					for (int i = 0; i < 10; ++i)
					{
						A_SpawnParticle(fillcolor, SPF_RELATIVE | SPF_FULLBRIGHT, random(25, 50), frandom(8, 16) * healthFac, random(0, 359), radius * healthFac, 0, frandom(10, height), frandom(0.15, 1.25) * healthFac, accelz: -0.02 * healthFac);
					}
				}
				if (healthFac < 0.75) { frame++; height = 30; }
				if (healthFac < 0.25) { frame++; height = 20; }
			}
			Loop;
		Death:
			TNT1 A 1;
			Stop;
	}
}

class TiberiumChunk : HDUPK
{
	override void PostBeginPlay()
	{
		RollDirection = randompick(-1, 1);
		if (IsBlue)
		{
			SetShade(0x3388FF);
			MaxUnitAmount = int(MaxUnitAmount * TiberiumCrystal.BlueScale);
		}
		Super.PostBeginPlay();
	}

	override void A_HDUPKGive()
	{
		int maxAmt = GetDefaultByType('MercenaryBucks').MaxAmount;
		int toGive = min(Amount, maxAmt - picktarget.CountInv('MercenaryBucks'));

		if (toGive > 0)
		{
			picktarget.A_GiveInventory('MercenaryBucks', toGive);
			Amount -= toGive;

			picktarget.A_StartSound(pickupsound, 5);
			HDPickup.LogPickupMessage(picktarget, "Picked up a chunk of Tiberium worth "..(IsBlue ? "\c[Blue]" : "\c[Green]").."$"..toGive.."\c-.");
			
			bool hasRadsuit = picktarget.FindInventory('WornRadsuit') != null;
			picktarget.DamageMobj(self, self, hasRadsuit ? random(2, 5) : random(10, 16), 'Tiberium', DMG_NO_FACTOR);
			let hdplr = HDPlayerPawn(picktarget);
			if (hdplr)
			{
				if (hasRadsuit)
				{
					if (random(1, 100) <= Amount / 2)
					{
						hdplr.burncount++;
					}
				}
				else
				{
					hdplr.burncount += max(2, Amount / 10);
					hdplr.woundcount += max(1, Amount / 20);
				}
			}
		}

		if (Amount <= 0)
		{
			Destroy();
		}
	}

	bool IsBlue;
	int RollDirection;

	Default
	{
		BounceType "Doom";
		BounceFactor 0.6;
		BounceCount 8;
		HDUPK.MaxUnitAmount 100;
		+MISSILE
		+EXPLODEONWATER
		+ROLLSPRITE
		+ROLLCENTER
		Scale 0.4;
		StencilColor "66FF44";
		BounceSound "Tiberium/Bounce";
	}

	States
	{
		RegisterSprites:
			TBCG A 0; TBCB A 0;

		Spawn:
			TBCG A 5 NoDelay
			{
				if (IsBlue)
				{
					sprite = GetSpriteIndex("TBCB");
				}
				roll += 30 * RollDirection;

				double amtFac = max(0.3, Amount / double(MaxUnitAmount));
				if (amtFac < 0.75) { frame++; }
				if (amtFac < 0.25) { frame++; }
			}
			Loop;
		Death:
			#### # 0
			{
				A_StartSound(bouncesound);
				roll = randompick(0, 180);
			}
		DeathLoop:
			#### # 3
			{
				if (random(1, 100) <= 40)
				{
					double amtFac = max(0.3, Amount / double(MaxUnitAmount));
					for (int i = 0; i < 10; ++i)
					{
						A_SpawnParticle(fillcolor, SPF_RELATIVE | SPF_FULLBRIGHT, random(10, 30), frandom(6, 10) * amtFac, random(0, 359), 4 * amtFac, 0, frandom(0, 12) * amtFac, frandom(0.05, 1.0) * amtFac);
					}
				}
			}
			Loop;
	}
}