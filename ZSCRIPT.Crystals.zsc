class TiberiumRadiationThinker : Thinker
{
	Sector ActiveSec;
	Array<TiberiumCrystal> Crystals;

	private int DamageTicker;

	override void Tick()
	{
		Super.Tick();
		for (int i = 0; i < Crystals.Size(); ++i)
		{
			if (!Crystals[i])
			{
				Crystals.Delete(i--);
			}
		}

		int crystalCount = Crystals.Size();
		if (crystalCount == 0)
		{
			Destroy();
			return;
		}

		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (!players[i].mo || players[i].mo.CurSector != ActiveSec)
			{
				continue;
			}

			bool hasRadsuit = players[i].mo.FindInventory('WornRadsuit') != null;
			int damChance = hasRadsuit ? 5 : 100;
			int damFreq = max(5, 30 - crystalCount);
			damChance += crystalCount / 3;

			if (++DamageTicker >= damFreq)
			{
				DamageTicker = 0;
				if (random(1, 100) <= damChance)
				{
					players[i].mo.DamageMobj(null, null, hasRadsuit ? random(2, 4) : random(8, 12), 'Tiberium', DMG_NO_FACTOR);

					let hdplr = HDPlayerPawn(players[i].mo);
					if (hdplr)
					{
						if (random(1, 100) <= damChance / (hasRadsuit ? 2 : 1))
						{
							hdplr.burncount += randompick(1, 1, 1, 1, 2);
						}
						if (!hasRadsuit)
						{
							hdplr.woundcount++;
						}
					}
				}
			}
		}
	}
}

extend class MerchantHandler
{
	// [Ace] These are the opposite of healing crystals, so keep soccer moms away.
	private void SpawnCrystals(Sector s)
	{
		double size, avgSize;
		[size, avgSize] = AceCore.GetSectorSize(s);

		double scaleFac = max(1.0, frandom[merchrand](-2.0, 3.0));
		int totalCrystalHealth = int(size * scaleFac);
		int originalTotal = totalCrystalHealth;

		// [Ace] I'm not using a for loop because it can potentially result in fewer than the real number of crystals to spawn.
		int tries = 0;
		TiberiumRadiationThinker tibThonk = null;

		int lowest = int.max, average = 0, highest = 0;
		while (totalCrystalHealth > 0 && tries < 5000) // [Ace] If 5000 tries dont't do it, it's likely a super tiny sector OR it's a control sector. Fringe cases probably can't be handled too well.
		{
			double angle = random(0, 359);
			double dist = frandom(0, size);
			vector3 adjPos = (s.centerspot + (dist * cos(angle), dist * sin(angle)), s.floorplane.ZAtPoint(s.centerspot));
			if (level.IsPointInLevel(adjPos) && level.PointInSector(adjPos.xy) == s)
			{
				Actor a = Actor.Spawn('TiberiumCrystal', adjPos);
				a.Health = min(totalCrystalHealth, random[merchrand](50, 300));
				if (!tibThonk)
				{
					tibThonk = new('TiberiumRadiationThinker');
					tibThonk.ActiveSec = s;
				}
				tibThonk.Crystals.Push(TiberiumCrystal(a));
				totalCrystalHealth -= a.Health;

				if (a.Health < lowest)
				{
					lowest = a.Health;
				}
				if (highest < a.Health)
				{
					highest = a.Health;
				}
				average += a.Health;
			}
			tries++;
		}

		int crystalCount = tibThonk ? tibThonk.Crystals.Size() : 0;
		if (crystalCount > 0)
		{
			average /= crystalCount;
		}

		if (hdm_debug)
		{
			Console.Printf("--------------------\nSpawned \c[Green]%i\c- crystals. Remaining health: \c[Red]%i\c- out of \c[Red]%i\c- (x \c[Red]%.2f\c-). Low/avg/high: \c[Red]%i\c-/\c[Red]%i\c-/\c[Red]%i\c-.\nSector @\c[DarkGray]%i\c-, \c[DarkGray]%i\c- size/avg is \c[Brick]%i\c-/\c[Brick]%i\c-. Took \c[Gold]%i\c- tries.",
				crystalCount, totalCrystalHealth, originalTotal, scaleFac, lowest, average, highest, s.centerspot.x, s.centerspot.y, size, avgSize, tries);
		}
	}
}

class TiberiumCrystal : Actor
{
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		NextDropAmount = NextDropAt = min(Health, random(20, 100));
	}

	private void DropChunk()
	{
		HDUPK a = HDUPK(Spawn('TiberiumChunk', pos));
		a.Amount = NextDropAmount;
		a.angle = random(0, 359);
		//a.frame = random(0, 1);
		a.A_ChangeVelocity(frandom(0.5, 2.0), 0, frandom(1.0, 3.0), CVF_RELATIVE | CVF_REPLACE);

		int leftover = abs(NextDropAt);
		NextDropAmount = NextDropAt = min(Health, random(35, 100)) - leftover;
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (mod == 'Chainsaw')
		{
			int dmg = Super.DamageMobj(inflictor, source, damage / 5, mod, flags, angle);

			NextDropAt -= dmg;
			if (NextDropAt <= 0)
			{
				DropChunk();
			}

			double pitch = frandom(-85.0, 85.0);
			bool success; Actor a;
			[success, a] = A_SpawnItemEx('HDSmoke', frandom(0, radius), 0,  frandom(0, height), frandom(1, 3) * cos(pitch), 0, frandom(1, 3) * sin(pitch), random(0, 359), SXF_NOCHECKPOSITION);
			a.scale = (0.6, 0.6) * frandom(0.75, 1.2);
			a.A_SetRenderStyle(1.25, STYLE_AddShaded);
			a.SetShade(0x22FF00);

			return dmg;
		}
		return 0;
	}

	private int NextDropAt;
	private int NextDropAmount;

	Default
	{
		Radius 14;
		Height 40;
		Health 300;
		Mass 50000;
		Renderstyle "Add";
		Alpha 1.2;
		+SOLID
		+ROLLSPRITE
		+SHOOTABLE
		+DONTTHRUST
		+NOBLOOD
	}

	States
	{
		Spawn:
			TBCR # 3
			{
				if (random(1, 100) <= 40)
				{
					for (int i = 0; i < 10; ++i)
					{
						A_SpawnParticle(0x66FF44, SPF_RELATIVE | SPF_FULLBRIGHT, random(25, 50), frandom(8, 16) * scale.x, random(0, 359), radius - 8, 0, random(0, 8), frandom(0.1, 1.0));
					}
				}
				alpha = default.alpha * frandom(0.75, 1.5);
				scale = default.scale * ((3 + Health / 50) / 10.0); // [Ace] Intentionally done like that to round to increments of 0.1
				height = default.height * scale.y;
			}
			Loop;
		Death:
			TNT1 A 1
			{
				CurSector.damageamount--;
			}
			Stop;
	}
}

class TiberiumChunk : HDUPK
{
	override void A_HDUPKGive()
	{
		int maxAmt = GetDefaultByType('MercenaryBucks').MaxAmount;
		int toGive = min(Amount, maxAmt - picktarget.CountInv('MercenaryBucks'));

		if (toGive > 0)
		{
			picktarget.A_GiveInventory('MercenaryBucks', toGive);
			Amount -= toGive;

			picktarget.A_StartSound(pickupsound, 5);
			HDPickup.LogPickupMessage(picktarget, "Picked up a chunk of Tiberium worth \c[Green]$"..toGive.."\c-.");
			
			bool hasRadsuit = picktarget.FindInventory('WornRadsuit') != null;
			picktarget.DamageMobj(self, self, hasRadsuit ? random(2, 5) : random(10, 16), 'Tiberium', DMG_NO_FACTOR);
			let hdplr = HDPlayerPawn(picktarget);
			if (hdplr)
			{
				if (hasRadsuit)
				{
					if (random(1, 100) <= Amount / 2)
					{
						hdplr.burncount++;
					}
				}
				else
				{
					hdplr.burncount += max(2, Amount / 10);
					hdplr.woundcount += max(1, Amount / 20);
				}
			}
		}

		if (Amount <= 0)
		{
			Destroy();
		}
	}

	Default
	{
		BounceType "Doom";
		BounceFactor 0.6;
		BounceCount 8;
		HDUPK.Amount 100;
		Renderstyle "Add";
		Alpha 0.8;
		+MISSILE
		+EXPLODEONWATER
		Scale 0.3;
	}

	States
	{
		Spawn:
			TBCH A -1 NoDelay
			{
				scale = default.scale * max(0.4, (Amount / 100.0));
			}
			Stop;
		Death:
			TBCH A 3
			{
				alpha = default.alpha * frandom(0.75, 1.25);
				if (random(1, 100) <= 40)
				{
					for (int i = 0; i < 10; ++i)
					{
						A_SpawnParticle(0x66FF44, SPF_RELATIVE | SPF_FULLBRIGHT, random(10, 30), frandom(6, 10) * scale.x, random(0, 359), 5 * scale.x, 0, frandom(0, 4) * scale.y, frandom(0.05, 0.7) * scale.x);
					}
				}
			}
			Loop;
	}
}
