class TiberiumRadiationThinker : Thinker
{
	Sector ActiveSec;
	Array<TiberiumCrystal> Crystals;

	private int DamageTicker;

	override void Tick()
	{
		Super.Tick();
		for (int i = 0; i < Crystals.Size(); ++i)
		{
			if (!Crystals[i])
			{
				Crystals.Delete(i--);
			}
		}

		int crystalCount = Crystals.Size();
		if (crystalCount == 0)
		{
			Destroy();
			return;
		}

		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (!players[i].mo || players[i].mo.CurSector != ActiveSec)
			{
				continue;
			}

			bool hasRadsuit = players[i].mo.FindInventory('WornRadsuit') != null;
			int damChance = hasRadsuit ? 5 : 100;
			int damFreq = max(5, 30 - crystalCount);
			damChance += crystalCount / 3;

			if (++DamageTicker >= damFreq)
			{
				DamageTicker = 0;
				if (random(1, 100) <= damChance)
				{
					players[i].mo.DamageMobj(null, null, hasRadsuit ? random(2, 4) : random(8, 12), 'Tiberium');

					let hdplr = HDPlayerPawn(players[i].mo);
					if (hdplr)
					{
						if (random(1, 100) <= damChance / (hasRadsuit ? 2 : 1))
						{
							hdplr.burncount += randompick(1, 1, 1, 1, 2);
						}
						if (!hasRadsuit)
						{
							hdplr.woundcount++;
						}
					}
				}
			}
		}
	}
}

extend class MerchantHandler
{
	// [Ace] These are the opposite of healing crystals, so keep soccer moms away.
	private void SpawnCrystals(Sector s)
	{
		double size = AceCore.GetSectorSize(s);
		int sizeDiv = random(256, 384);
		int crystalsToSpawn = int(max(randompick(3, 4, 4, 4), size / sizeDiv));

		int allCrystals = crystalsToSpawn; // [Ace] Used for debugging.

		// [Ace] I'm not using a for loop because it can potentially result in fewer than the real number of crystals to spawn.
		int tries = 0;
		TiberiumRadiationThinker tibThonk = null;
		while (crystalsToSpawn > 0 && tries < 2000) // [Ace] If it takes more than 2000 tries, something's really fucked.
		{
			double angle = random(0, 359);
			double dist = frandom(0, size);
			vector3 adjPos = (s.centerspot + (dist * cos(angle), dist * sin(angle)), s.floorplane.ZAtPoint(s.centerspot));
			if (level.IsPointInLevel(adjPos) && level.PointInSector(adjPos.xy) == s)
			{
				Actor a = Actor.Spawn('TiberiumCrystal', adjPos);
				a.Health = random[merchrand](100, 700);
				a.roll = random(-5, 5);
				a.frame = random(0, 1);
				if (!tibThonk)
				{
					tibThonk = new('TiberiumRadiationThinker');
					tibThonk.ActiveSec = s;
				}
				tibThonk.Crystals.Push(TiberiumCrystal(a));
				crystalsToSpawn--;
			}
			tries++;
		}

		if (hdm_debug || tries >= 2000)
		{
			Console.Printf("Spawned %i/%i crystals. Sector (@%i, %i) size is %i (div %i). Took %i tries.", (tibThonk ? tibThonk.Crystals.Size() : 0), allCrystals, s.centerspot.x, s.centerspot.y, size, sizeDiv, tries);
			if (tries >= 2000)
			{
				Console.Printf("Crystal generation took over 2000 tries. Something is very wrong. Screenshot this message and report to Ace with map name.");
			}
		}
	}
}

class TiberiumCrystal : Actor
{
	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (mod == 'Chainsaw')
		{
			if (random[merchrand](1, 100) <= damage - 10)
			{
				HDUPK a = HDUPK(Spawn('TiberiumChunk', pos));
				a.Amount = random[merchrand](20, 60);
				a.angle = random(0, 359);
				//a.frame = random(0, 1);
				a.A_ChangeVelocity(frandom(0.5, 2.0), 0, frandom(1.0, 3.0), CVF_RELATIVE | CVF_REPLACE);
			}
			for (int i = 0; i < 10; ++i)
			{
				double pitch = frandom(-85.0, 85.0);
				A_SpawnParticle(0x22FF00, SPF_RELATIVE | SPF_FULLBRIGHT, random(6, 10), random(4, 6), random(0, 359), frandom(-radius, radius), 0, frandom(0, height), random(6, 12) * cos(pitch), 0, random(6, 12) * sin(pitch), 0, 0, -1);
			}
			return Super.DamageMobj(inflictor, source, damage / 4, mod, flags, angle);
		}
		return 0;
	}

	Default
	{
		Radius 14;
		Height 40;
		Health 500;
		Mass 50000;
		Renderstyle "Add";
		Alpha 1.2;
		+SOLID
		+ROLLSPRITE
		+SHOOTABLE
		+DONTTHRUST
		+NOBLOOD
	}

	States
	{
		Spawn:
			TBCR # 3
			{
				if (random(1, 100) <= 40)
				{
					for (int i = 0; i < 10; ++i)
					{
						A_SpawnParticle(0x22FF00, SPF_RELATIVE | SPF_FULLBRIGHT, random(25, 50), frandom(8, 16) * scale.x, random(0, 359), radius - 8, 0, random(0, 8), frandom(0.1, 1.0));
					}
				}
				alpha = default.alpha * frandom(0.75, 1.5);
				scale = default.scale * ((4 + Health / 150) / 10.0); // [Ace] Intentionally done like that to round to increments of 0.1
				height = default.height * scale.y;
			}
			Loop;
		Death:
			TNT1 A 0
			{
				CurSector.damageamount--;
			}
			Stop;
	}
}

class TiberiumChunk : HDUPK
{
	override void A_HDUPKGive()
	{
		let storage = MerchantRewardStorage.Get();
		storage.Money += Amount;
		
		picktarget.A_StartSound(pickupsound, 5);
		HDPickup.LogPickupMessage(picktarget, pickupmessage);
		
		bool hasRadsuit = picktarget.FindInventory('WornRadsuit') != null;
		picktarget.DamageMobj(self, self, hasRadsuit ? random(2, 5) : random(10, 16), 'Balefire');
		let hdplr = HDPlayerPawn(picktarget);
		if (hdplr)
		{
			if (hasRadsuit)
			{
				if (random(1, 100) <= 50)
				{
					hdplr.burncount++;
				}
			}
			else
			{
				hdplr.burncount += randompick(2, 2, 2, 2, 3, 3, 4, 5);
				hdplr.woundcount += randompick(1, 1, 1, 2, 2, 2, 3);
			}
		}

		Destroy();
		return;
	}

	Default
	{
		BounceType "Hexen";
		BounceFactor 0.6;
		BounceCount 8;
		HDUPK.PickupMessage "Picked up a chunk of tiberium.";
		HDUPK.Amount 100;
		Renderstyle "Add";
		Alpha 0.8;
		+MISSILE
	}

	States
	{
		Spawn:
			TBCH A -1 NoDelay
			{
				scale = default.scale * (0.20 + Amount / 400.0);
			}
			Stop;
		Death:
			TBCH A 3
			{
				alpha = default.alpha * frandom(0.75, 1.25);
				if (random(1, 100) <= 40)
				{
					for (int i = 0; i < 10; ++i)
					{
						A_SpawnParticle(0x22FF00, SPF_RELATIVE | SPF_FULLBRIGHT, random(10, 30), frandom(8, 12) * scale.x, random(0, 359), 0, 0, frandom(0, 4), frandom(0.05, 0.7));
					}
				}
			}
			Loop;
	}
}
